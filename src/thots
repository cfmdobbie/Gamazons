================================================================================
DONE
================================================================================


* Redo
	This is completely useless.  If an undo has been done a couple of times,
	and a different move has been made, Redoing by moving up a state in the
	state array would completely void the different move that just took
	place.  If a user Undos once, he can just make the same move again if he
	really wants.  This just looks like it would create more bugs and not
	add any useful functionality.

* Undo/Redo menu
	There's already a convenient Undo button on the game board.  Having two
	separate ways to access this feature is unnecessary and bug-prone.  I'd
	have to make sure that whenever one is disabled, the other is disabled
	too.  Just dump the menu options, it's not very useful.

* Handling Interrupts 
	move_ai() should call a function to disable certain event handling instead of
       	just having a silly global variable.  For instance, it could gray out the
       	Auto Finish button so the user knows it's not going to do anything when he 
	presses it.  Perhaps the 'Force Move' button should be greyed out until the AI
       	is thinking, or since Force Move & Auto Finish are mutually exclusive, it would
       	be cool to have the button switch labels depending on the state of the game.

	gtk_button_set_label(GtkButton *button, const gchar *label);
	gtk_widget_set_sensitive (GtkWidget *widget, gboolean sensitive);
   	time = lookup_widget(PlayerSettingsWindow, "TimeSpinner");

* Have a popup declaring the winner
* Computer moving queens:  
	Instead of having the queens just pop around on the board when the
	computer is moving, the queen should slide so the human can see what
	piece is moving.  I should be able to do some kind of move, maybe one
	pixel at a time.  Just calculate the origin and the destination, and
	they _should_ just be straight diagonal (increment x coord by 1,
	increment y coord by 1, draw), or horiz or vert.  If moving by 1 is too
	slow, we could make it 2 or whatever.

* Remembering values:
	I need to store user options in a .gamazons file.  When the user presses
	OK in the player preferences, the values should be stored in this file
	as well as in the global options struct.  Then, init_engine() should read
	in the values from a file (if it exists).

* Website requirements:
	Explain how I verified that my program works
	Explain what it takes to compile and run the program
		Requires Gnome2
		tweak a header file to compile amazons instead of gamazons
	Post source code
		Include a copy of the GPL w/ the source
	Explain what it takes to run the program and how to use it

* Keeping the GUI & engine in sync
	Currently, amazons has a state stucture that is local to main and passed
	around wherever deemed necessary.  Gamazons needs access to this, so
	maybe I should make it global.  I can still make a pointer to the global
	and pass that around so I don't have to mess around with all the
	function prototypes.

	I need to create some coordinate conversion routines though, since 0,0
	is in the bottom left for amazons, and top left for gamazons.

	I also need to find a way to let the engine know when it's the AI's turn 
	to move.  I may need to take out it's ability to think during its
	opponent's turn for this to work properly.

	I currently keep track of game state on the GUI side as well as on the
	engine side.  Should I dump the gui state and focus on the engine state?
	Or is the convenience of not having to convert coordinates every time I
	need to use one worth the inconvenience of keeping both in sync during
	every change? -- Ugh, keep two, just keep them in sync.
	
* User input while the AI is thinking...
	I should set a flag at the beginning of move_ai() that sez the computer
	is thinking.  Then at the beginning of all callbacks, I should check to
	see if the AI is preparing to move and ignore all user input until it's
	safe.  While I'm at it, I should also make a check that if it is a human
	player who's turn it is to move, that the human is moving his own
	pieces.  ie, if it's white's turn, he shouldn't be able to pick up black
	pieces.

* Playing the game
	Once the board is drawn and all the signals are registered, call a
	function that checks if the first player is the AI or human.  If it's
	the AI, start the searching process for the next move.  If it's a human,
	just fall out of the function and don't do anything until the human
	makes the first move (or maybe I could start the thinking process while
	the human thinks also.  However, that may be more complicated and I
	should start small and work into that one).  Then at the end of
	processing the move signal (perhaps at the end of the fire_arrow
	callback), I could check if the next move is done by human or AI.

	I'll probably have two different functions for processing human moves
	and AI moves, so I'd better make sure both work.

* Text mode vs GUI mode
	I would like to maintain both versions, as each one has its place.
	Everything that's text dependent should be bracketed with 
	#ifndef GAMAZONS, and stuff that's GUI dependent should be bracketed
	with #ifdef GAMAZONS.  

* handling options:
	Instead of having several dozen global variables, each covering a
	different option, I could make one big structure, covering all options.
	Then I can create sub structs for network, players, etc...

* Drawing the board
   	it looks like I can use gnome_canvas_item_move to move a queen already placed
       	on the board.  Perhaps I should draw the board initially, registering all the
       	callbacks with them, etc... and then just use that to move them.  But then what
       	does the draw_board function do?  gnome-chess called it all the time. 

	looks like gnome chess just used board_update to see if any pieces were taken
       	and deletes them if they are.  I don't know if I need to draw the board after
       	the initial draw.

================================================================================
TODO
================================================================================

* Showing the latest square fired on:
  	The square the AI (or human) fired it's arrow on could be a different color 
	or shade until the next move starts.

* Undo
	Instead of having a straight state struct, maybe I should have an array
	of 100 of them.  Then I could include a current move state and a max move
	state so I could skip forward and backward.  

	Hmm, should I keep 100 of both states? or just keep all those states on
	the engine side, and use the GUI state only for the current state of the
	board?  I'm currently inclined to just have the array on the engine
	side.

	What should Undo do?  If a human player has moved a piece but not fired
	yet, undo should just move the piece back.  In this case, the engine
	wouldn't need to be notified because the move isn't registered to the
	engine until the arrow is fired.  If the human is playing an AI, the
	Undo should go back to the last human opponent.  

	When can Undo be used?  Once autofinish has started, Undo won't be able
	to find a human opponent.  So it should be disabled once autofinish
	starts.  I don't want the AI interrupted by Undo once it has started
	moving, so it should be disabled once move_ai() starts, and can be
	renabled at the end.


* Keeping up with option/game changes
	Some options may change during the middle of the game.  For example, the
	autocomplete would make both players computer opponents.  The network
	stuff wouldn't be able to change.  Each time the back end has to use one
	of these changeable options, it should read it directly from the source.
	
	But if we had a setup mode, the user could switch off game playing, configure 
	the board, and reenter game mode.  To accomplish this, I'd need to change game 
	recognition from a linear model (W moved this queen here, so unmark the src 
	and mark the dest as the WQ), to a discover mode (look at all the squares on 
	the board and see what is on each).  That's not very efficient for most things,
       	so perhaps just making a " discover_board" function that can be called when 
	exiting setup mode.


* Different difficulty levels & Separate AI settings for each player
	I want to create different difficulty levels for the AI player.
	Starting with 0 = random and moving up to 10 or so, adding one more
	heuristic at each level.  

	But then I'd like to separate the AI level, time, width, and TT.  That
	way I can pit one player up against the other without them "cheating" by
	knowing what the other player will do.  

* Generate the moves list
	I've got that nice fancy window taking up precious real estate.  I might
	as well use it for what it was for.

* Text looks messed up with custom fonts & fixed game board size	
	On Michael's computer, the game looked pretty screwy.  I dunno what
	font settings he used, but it made it look pretty messed up.
	Unfortunately, my board is designed to be precisely the size it is.  The
	user doesn't have the ability to resize the game, board or pieces.
	Unfortunately, this means people with high resolutions can't make the
	board any bigger and people with low resolutions can't make it any
	smaller.  To change this, I'd need to learn how to scale the pieces, the
	game board, and redo all the calculations which determine where pieces
	are and where to move them to.  If this were fixed, people with
	different fonts could resize the board so it looked normal to them.

* Networking
	Don't bother with a client/server relationship (eg freeciv).  This game should 
	just be peer based.  Just pick some random unused port as a default.
	The user should be able pick whatever port he wants, and whatever he
	selects should be stored in the .gamazons file.

* Where to store the .gamazons file
	I noticed gnome-chess stored the user config file in the .gnome
	directory.  Perhaps there's a standard location for gnome's config files
	that I can retreive via some gnome function call.
