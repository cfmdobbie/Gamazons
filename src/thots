* it looks like I can use gnome_canvas_item_move to move a queen already placed
on the board.  Perhaps I should draw the board initially, registering all the
callbacks with them, etc... and then just use that to move them.  But then what
does the draw_board function do?  gnome-chess called it all the time.  

looks like gnome chess just used board_update to see if any pieces were taken
and deletes them if they are.  I don't know if I need to draw the board after
the initial draw.


* Computer moving queens:  
	Instead of having the queens just pop around on the board when the
	computer is moving, the queen should slide so the human can see what
	piece is moving.  I should be able to do some kind of move, maybe one
	pixel at a time.  Just calculate the origin and the destination, and
	they _should_ just be straight diagonal (increment x coord by 1,
	increment y coord by 1, draw), or horiz or vert.  If moving by 1 is too
	slow, we could make it 2 or whatever.

* handling options:
	Instead of having several dozen global variables, each covering a
	different option, I could make one big structure, covering all options.
	Then I can create sub structs for network, players, etc...

* Keeping up with option/game changes
	Some options may change during the middle of the game.  For example, the
	autocomplete would make both players computer opponents.  The network
	stuff wouldn't be able to change.  Each time the back end has to use one
	of these changeable options, it should read it directly from the source.
	
	But if we had a setup mode, the user could switch off game playing, configure 
	the board, and reenter game mode.  To accomplish this, I'd need to change game 
	recognition from a linear model (W moved this queen here, so unmark the src 
	and mark the dest as the WQ), to a discover mode (look at all the squares on 
	the board and see what is on each).  That's not very efficient for most things,
       	so perhaps just making a " discover_board" function that can be called when 
	exiting setup mode.


* Text mode vs GUI mode
	I would like to maintain both versions, as each one has its place.
	Everything that's text dependent should be bracketed with 
	#ifndef GAMAZONS, and stuff that's GUI dependent should be bracketed
	with #ifdef GAMAZONS.  

* Keeping the GUI & engine in sync
	Currently, amazons has a state stucture that is local to main and passed
	around wherever deemed necessary.  Gamazons needs access to this, so
	maybe I should make it global.  I can still make a pointer to the global
	and pass that around so I don't have to mess around with all the
	function prototypes.

	I need to create some coordinate conversion routines though, since 0,0
	is in the bottom left for amazons, and top left for gamazons.

	I also need to find a way to let the engine know when it's the AI's turn 
	to move.  I may need to take out it's ability to think during its
	opponent's turn for this to work properly.

	I currently keep track of game state on the GUI side as well as on the
	engine side.  Should I dump the gui state and focus on the engine state?
	Or is the convenience of not having to convert coordinates every time I
	need to use one worth the inconvenience of keeping both in sync during
	every change? -- Ugh, keep two, just keep them in sync.
	
* Undo
	Instead of having a straight state struct, maybe I should have an array
	of 100 of them.  Then I could include a current move state and a max move
	state so I could skip forward and backward.  

	Hmm, should I keep 100 of both states? or just keep all those states on
	the engine side, and use the GUI state only for the current state of the
	board?  I'm currently inclined to just have the array on the engine
	side.

* Playing the game
	Once the board is drawn and all the signals are registered, call a
	function that checks if the first player is the AI or human.  If it's
	the AI, start the searching process for the next move.  If it's a human,
	just fall out of the function and don't do anything until the human
	makes the first move (or maybe I could start the thinking process while
	the human thinks also.  However, that may be more complicated and I
	should start small and work into that one).  Then at the end of
	processing the move signal (perhaps at the end of the fire_arrow
	callback), I could check if the next move is done by human or AI.

	I'll probably have two different functions for processing human moves
	and AI moves, so I'd better make sure both work.

* User input while the AI is thinking...
	I should set a flag at the beginning of move_ai() that sez the computer
	is thinking.  Then at the beginning of all callbacks, I should check to
	see if the AI is preparing to move and ignore all user input until it's
	safe.  While I'm at it, I should also make a check that if it is a human
	player who's turn it is to move, that the human is moving his own
	pieces.  ie, if it's white's turn, he shouldn't be able to pick up black
	pieces.


* Website requirements:
	Explain how I verified that my program works
	Explain what it takes to compile and run the program
		Requires Gnome2
		tweak a header file to compile amazons instead of gamazons
	Post source code
		Include a copy of the GPL w/ the source
	Explain what it takes to run the program and how to use it
	
